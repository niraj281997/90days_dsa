#include<iostream>

using namespace std;
/*Shallow Copy: 

Shallo copy constructor is can be generated by the compiler if we don't provide one.

Shallow repetition is quicker. However, it’s “lazy” it handles pointers and references.
Rather than creating a contemporary copy of the particular knowledge the pointer points to, it simply copies over the pointer price. 
So, each of the first and therefore the copy can have pointers that reference constant underlying knowledge.
If the first object is deleted, the copy can have a pointer that’s currently referencing nothing.
If the copy is deleted, it’ll attempt to delete the constant knowledge that the first object is already deleted.
This can cause a crash.

*/
class A
{
    private:
        int x;
        int *p;
    public:

    A(int i = 0)
    {
        x = i;
        p = new int;
        *p = 10;
    }
    A(const A &a)
    {
        x = a.x;
        p = a.p;
    }
    void change_pointer()
    {
        *p = cin.get();
    }
    void print()
    {
        cout<<"x = "<<x<<endl;
        cout<<"*p = "<<*p<<endl;
    }
  
};

int main()
{
    A a(10);
    a.print();
    A b = a;
    b.change_pointer();
    b.print();
    a.print();
    return 0;
}